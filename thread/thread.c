/**
 * 线程按照其调度者可以分为用户级线程和核心级线程两种。
 * （1）用户级线程。
 * 用户级线程主要解决的是上下文切换的问题，它的调度算法和调度过程全部由用户自行选择决定，在运行
 * 时不需要特定的内核支持。在这里，操作系统往往会提供一个用户空间的线程库，该线程库提供了线程的
 * 创建、调度和撤销等功能，而内核仍然仅对进程进行管理。如果一个进程中的某一个线程调用了一个阻塞
 * 的系统调用函数，那么该进程包括该进程中的其他所有线程也同时被阻塞。这种用户级线程的主要缺点是
 * 在一个进程中的多个线程的调度中无法发挥多处理器的优势。
 * （2）轻量级进程。
 * 轻量级进程是内核支持的用户线程，是内核线程的一种抽象对象。每个线程拥有一个或多个轻量级线程，
 * 而每个轻量级线程分别被绑定在一个内核线程上。
 * （3）内核线程。
 * 这种线程允许不同进程中的线程按照同一相对优先调度方法进行调度，这样就可以发挥多处理器的并发优势。
 * 现在大多数系统都采用用户级线程与核心级线程并存的方法。一个用户级线程可以对应一个或几个核心级
 * 线程，也就是“一对一”或“多对一”模型。这样既可满足多处理机系统的需要，也可以最大限度地减少
 * 调度开销。
 * 使用线程机制大大加快上下文切换速度而且节省很多资源。但是因为在用户态和内核态均要实现调度管
 * 理，所以会增加实现的复杂度和引起优先级翻转的可能性。一个多线程程序的同步设计与调试也会增加程
 * 序实现的难度。
 */

/**
 * 创建线程实际上就是确定调用该线程函数的入口点，这里通常使用的函数是 pthread_create()。在线程创建
 * 以后，就开始运行相关的线程函数，在该函数运行完之后，该线程也就退出了，这也是线程退出一种方法。
 * 另一种退出线程的方法是使用函数 pthread_exit()，这是线程的主动行为。这里要注意的是，在使用线程函
 * 数时，不能随意使用 exit()退出函数进行出错处理，由于 exit()的作用是使调用进程终止，往往一个进程包
 * 含多个线程，因此，在使用 exit()之后，该进程中的所有线程都终止了。因此，在线程中就可以使用
 * pthread_exit()来代替进程中的 exit()。
 */



